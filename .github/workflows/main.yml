name: CI

# Environment Variables
env:
  DOCKER_REPO: furiousgeorge/elodie
  SCHEDULE_TAG: unstable
  TAGS: latest
  PUSH: true

# Controls when the action will run. Triggers the workflow on push or pull request
# events but only for the master branch
on:
  push:
    branches: [ master ]
    tags: # tags that start with vd.d.d
      - v[0-9]+.[0-9]+.[0-9]+
  pull_request:
    branches: [ master ]
  schedule:
    #- cron: '0 2 * * 0' # Weekly on Sundays at 02:00
    - cron: '*/5 * * * *' # Every 5 minutes

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Get Next Version
        id: vars
        run: |
          ref=$(echo $GITHUB_REF | awk -F'/' '{print $NF}')
          reftype=$(echo $GITHUB_REF | awk -F'/' '{print $2}')
          if [ "$reftype" == "tags" ]; then
            tempversion=$(echo "$ref" | sed -e "s/^v//")
            if [[ $tempversion =~ ^[0-9]+(\.[0-9]+){3}$ ]]; then
              version=$tempversion
            elif [[ $tempversion =~ ^[0-9]+(\.[0-9]+){2}$ ]]; then
              version="$tempversion.0"
            fi
          fi

          if [ -z "$version" ]; then
            # Get version from latest image on docker hub
            version=$(./.github/build/get_docker_version.sh $DOCKER_REPO)
          fi
           
          # if the latest image does not have the version label
          # get it from a version file in this repository
          # if the version file does not exist, hardcoded version
          if [ -n "$version" ]; then
            echo "Using version from tag or latest: $version"
          else
            version=$(cat ./version 2>/dev/null || echo "1.0.0.1");
            echo "Getting version from this job: $version"
          fi

          finalversion=$version

          versionstart=$(echo $version | awk 'BEGIN{FS=OFS="."}{NF--; print}' )
          build=$(echo $version | awk -F'.' '{print $NF}')

          head_sha=$(git rev-parse HEAD)
          tag_sha=$(git rev-list -n 1 $version 2>/dev/null || true)

          if [ -n "$GITHUB_SHA" ] && [ "$head_sha" != "${tag_sha}" ]; then
            newbuild=$(($build + 1))
            finalversion="$versionstart.$newbuild"
          fi

          echo ::set-output name=version::$finalversion
          echo ::set-output name=timestamp::$(date '+%Y-%m-%dT%H:%M:%S%:z')
          
      - name: Display new version
        run: echo ${{steps.vars.outputs.version}}

      - name: Check if this run will push to the registry
        run: |

          ref=$(echo $GITHUB_REF | awk -F'/' '{print $NF}')
          reftype=$(echo $GITHUB_REF | awk -F'/' '{print $2}')
          # only push to registry if branch is master or tags
          if [ "$ref" != "master" ] &&  [ "$reftype" != "tags" ]; then
            echo ::set-env name=PUSH::$(echo "false")
            echo "Will not push to registry because branch is not master: $ref"
          fi

      - name: Select tags to push
        run: |
          if [ "$GITHUB_EVENT_NAME" == "schedule" ]; then
            # only build and push the unstable tag if it is a schedule
            echo ::set-env name=TAGS::$(echo "$SCHEDULE_TAG")
          else
            # add all tags together into one comma-separated string
            newtags=$(echo -n "$SCHEDULE_TAG,$TAGS ${{steps.vars.outputs.version}}" | awk -v RS='[, ]' '!a[$0]++' | paste -sd,)
            echo "Will build tags for: $newtags"
            echo ::set-env name=TAGS::$(echo "$newtags")
          fi

      - name: Build and push Docker images
        uses: docker/build-push-action@v1
        with:
          add_git_labels: true
          build_args: BUILD_DATE=${{steps.vars.outputs.timestamp}},VERSION=${{steps.vars.outputs.version}}
          push: ${{ env.PUSH }}
          repository: ${{ env.DOCKER_REPO }}
          tags: ${{ env.TAGS }}
          #tags: ${{ env.TAG }},${{steps.vars.outputs.version}},latest
          password: ${{ secrets.DOCKER_PASSWORD }}
          username: ${{ secrets.DOCKER_USERNAME }}
